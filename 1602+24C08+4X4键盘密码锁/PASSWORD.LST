C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE PASSWORD
OBJECT MODULE PLACED IN PASSWORD.OBJ
COMPILER INVOKED BY: E:\Keil C软件\C51\BIN\C51.EXE PASSWORD.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<reg52.h>
   2          #define uint unsigned int
   3          #define uchar unsigned char
   4          void key_scan();
   5          uchar count0,count1,count3,num,n=0,temp,a,j,count4;
   6          uchar mima[8];                                                  //初始密码存储区
   7          uchar tab_key[50];                                              //输入密码存储区
   8          uchar code table[]={ 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e
   9          };//led共阳数码管
  10          /*uchar code table[]={
  11          0x3f,0x06,0x5b,0x4f,
  12          0x66,0x6d,0x7d,0x07,
  13          0x7f,0x6f,0x77,0x7c,
  14          0x39,0x5e,0x79,0x71};   //led共阴数码管    */
  15          bit enterflag;                                                  //确认键按下与否的标志
  16          bit mimaflag;                                                   //密码正确与否的标志
  17          bit xiugaiflag;                                                 //修改密码标志  
  18          bit enter1flag;                                         //修改密码确认键标志    
  19          sbit red=P2^1;//P3^7
  20          sbit green=P2^0;
  21          sbit bell=P2^2;  //P3^6
  22          sbit rs=P2^6;    //2^0
  23           sbit rw=P2^5;   //P2^1
  24          sbit lcden=P2^7; //P2^2
  25          sbit scl=P3^0;   //P3^4
  26          sbit sda=P3^1;   //P3^5
  27          uchar code table1[]="input the passco";
  28          uchar code table2[]="de:     --------";
  29          uchar code table3[]="*";
  30          uchar code table4[]="right   (^_^)   ";
  31          uchar code table5[]="first  error!!!!";
  32          uchar code table6[]="second error!!!!";
  33          uchar code table7[]="third error see ";
  34          uchar code table8[]="u tomorrow (^_^)";
  35          uchar code table9[]="define the passc";
  36          uchar code table10[]="ode:    --------";
  37          uchar code table11[]="code   is    new";
  38          //******************************************************键盘消抖函数**************************************
             -*********************************
  39          void delay1()
  40          { ;; }
  41          void delay2(uchar x)
  42          {
  43   1              uchar a,b;
  44   1              for(a=x;a>0;a--)
  45   1               for(b=100;b>0;b--);
  46   1      }
  47          void delay3(uchar x)
  48          {
  49   1              uchar a,b;
  50   1              for(a=x;a>0;a--)
  51   1               for(b=200;b>0;b--);
  52   1               }      
  53          void delay(uint z)
  54          {
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 2   

  55   1              uint x,y;
  56   1              for(x=z;x>0;x--)
  57   1                      for(y=110;y>0;y--);
  58   1      }
  59          
  60          //******************************************************e^2room的初始化***********************************
             -*********************************
  61          void start()  //开始信号
  62          {       
  63   1              sda=1;   //书P171 时钟SCL线为高电平时，数据线SDA出现由高电平向低电平变化的情形时，启动I^2C总线数据传送。  
  64   1              delay1();
  65   1              scl=1;   //
  66   1              delay1();
  67   1              sda=0;   //
  68   1              delay1();
  69   1      }
  70          
  71          void stop()   //停止
  72          {
  73   1              sda=0;    //书P171时钟SCL线为高电平时，数据线SDA出现由低电平到高电平的变化的情形时，将停止I^2C总线数据传送
             -。
  74   1              delay1();
  75   1              scl=1;
  76   1              delay1();
  77   1              sda=1;
  78   1              delay1();
  79   1      }
  80          //****************************应答信号*************************************
  81          void respond()  
  82          {
  83   1              uchar i;
  84   1              scl=1;
  85   1              delay1();
  86   1              while((sda==1)&&(i<250))i++;    //书P176 应答sda为0，非应答为1
  87   1              scl=0;                                                  //释放总线              ？
  88   1              delay1();
  89   1      }
  90          
  91          void noack()
  92          {
  93   1      scl=1;
  94   1      delay1();
  95   1      scl=1;delay1();
  96   1      scl=0;delay1();
  97   1      sda=0;delay1();
  98   1      }
  99          
 100          
 101          
 102          //*****************************写字节操作函数**********************************
 103          void write_byte(uchar date)
 104          {
 105   1              uchar i,temp;
 106   1              temp=date;
 107   1              for(i=0;i<8;i++)
 108   1              {
 109   2                      temp=temp<<1;                   //保持最高位，左移到进位CY
 110   2                      scl=0;                          //scl上跳沿写入
 111   2                  delay1();
 112   2                      sda=CY;                   //溢出位
 113   2                      delay1();
 114   2                      scl=1;
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 3   

 115   2                      delay1();
 116   2                      scl=0;delay1();
 117   2              }
 118   1              scl=0;
 119   1              delay1();
 120   1              sda=1;//总线释放 ？
 121   1              delay1();
 122   1      }
 123          //*******************************读字节操作函数*****************************
 124          uchar read_byte()
 125          {
 126   1              uchar i,k;
 127   1              scl=0;
 128   1              delay1();
 129   1              sda=1;
 130   1              delay1();
 131   1              for(i=0;i<8;i++)
 132   1              {
 133   2                      scl=1;
 134   2                      delay1();       
 135   2                      k=(k<<1)|sda;    //或运算，放到最低位
 136   2                      scl=0;
 137   2                      delay1();       
 138   2              }
 139   1              return k;
 140   1      }
 141          //**********************************写地址函数******************************
 142          void write_add(uchar address,uchar date)
 143          {
 144   1              start();
 145   1              write_byte(0xa0);       //设备地址
 146   1              respond();
 147   1              write_byte(address);
 148   1              respond();
 149   1              write_byte(date);
 150   1              respond();
 151   1              stop();
 152   1      }
 153          //*******************************读地址函数*************************************
 154          uchar read_add(uchar address)
 155          {
 156   1              uchar date;
 157   1              start();
 158   1              write_byte(0xa0);
 159   1              respond();
 160   1              write_byte(address);
 161   1              respond();
 162   1              start();
 163   1              write_byte(0xa1);         //表示接收地址
 164   1              respond();
 165   1              date=read_byte();
 166   1              noack();
 167   1              stop();
 168   1              return date;
 169   1      }
 170          //***********************************************************LCD1602的初始化******************************
             -********************************
 171          void write_com(uchar com)                  //书P154   写命令函数
 172          {
 173   1              rs=0;            //RS为寄存器选择，高电平1时选择数据寄存器、低电平0时选择指令寄存器。
 174   1              lcden=0;
 175   1              P0=com;
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 4   

 176   1              delay(5);
 177   1              lcden=1;         //LCD的使能端高电平有效
 178   1              delay(5);
 179   1              lcden=0;        
 180   1      }
 181          
 182          void write_date(uchar date)              //写数据函数
 183          {
 184   1              rs=1;
 185   1              lcden=0;
 186   1              P0=date;
 187   1              delay(5);
 188   1              lcden=1;
 189   1              delay(5);
 190   1              lcden=0;        
 191   1      }
 192          
 193          //***************************************密码比较函数********************************
 194          bit mimacmp()                                   
 195          {
 196   1              bit flag;
 197   1              uchar i;
 198   1              for(i=0;i<8;i++)
 199   1                      {
 200   2                              if(mima[i]==tab_key[i])
 201   2                                      flag=1;
 202   2                              else
 203   2                                      {
 204   3                                      flag=0;
 205   3                                      i=8;
 206   3                                      }
 207   2                      }
 208   1              return(flag);                                                   //返回flag
 209   1      }
 210          
 211          ////**********************************LCD显示函数开始**************************************
 212          void lcd_display()
 213          {
 214   1      uchar i=0;
 215   1      write_com(0x80+0x40+8);//液晶操作中的写入，地址是0x80开头的，加0x40为写入第二行，加8则为确定地址。
 216   1      for(i=0;i<n;i++)
 217   1      {
 218   2      write_date(table3[0]);  //uchar code table3[]="*"
 219   2      }
 220   1      }
 221          
 222          
 223          //***************************************************************键盘功能分配函数群开始*******************
             -************************************
 224          //** 0 ** 1 **2 ** 3**                     
 225          //** 4** 5** 6 **7 **
 226          //**8** 9** 确认（A）  **无效（B）
 227          //**取消（C）**修改密码键（D）**确认修改键（E）**无效（F）
 228          
 229          void key_manage1()
 230          {
 231   1      tab_key[n]=0;    //数组的存储顺序是从n=0开始的，因此无论是哪个键先按下都会存入tab_key[0]
 232   1      n++;
 233   1      if(xiugaiflag==1)       //如果按下了修改键
 234   1      {
 235   2      mima[count4]=0;
 236   2      count4++;
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 5   

 237   2      }
 238   1      }
 239          
 240          void key_manage2()
 241          {
 242   1      
 243   1      tab_key[n]=1;
 244   1      n++;
 245   1      if(xiugaiflag==1)
 246   1      {
 247   2      mima[count4]=1;
 248   2      count4++;
 249   2      }
 250   1      }
 251          
 252          void key_manage3()
 253          {
 254   1      
 255   1      tab_key[n]=2;
 256   1      n++;
 257   1      if(xiugaiflag==1)
 258   1      {
 259   2      mima[count4]=2;
 260   2      count4++;
 261   2      }
 262   1      }
 263          
 264          void key_manage4()
 265          {
 266   1      tab_key[n]=3;
 267   1      n++;
 268   1      if(xiugaiflag==1)
 269   1      {
 270   2      mima[count4]=3;
 271   2      count4++;
 272   2      }
 273   1      }
 274          
 275          void key_manage5()
 276          {
 277   1      tab_key[n]=4;
 278   1      n++;
 279   1      if(xiugaiflag==1)
 280   1      {
 281   2      mima[count4]=4;
 282   2      count4++;
 283   2      }
 284   1      }
 285          
 286          void key_manage6()
 287          {
 288   1      tab_key[n]=5;
 289   1      n++;
 290   1      if(xiugaiflag==1)
 291   1      {
 292   2      mima[count4]=5;
 293   2      count4++;
 294   2      }
 295   1      }
 296          void key_manage7()
 297          {
 298   1      tab_key[n]=6;
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 6   

 299   1      n++;
 300   1      if(xiugaiflag==1)
 301   1      {
 302   2      mima[count4]=6;
 303   2      count4++;
 304   2      }
 305   1      }
 306          void key_manage8()
 307          {
 308   1      tab_key[n]=7;
 309   1      n++;
 310   1      if(xiugaiflag==1)
 311   1      {
 312   2      mima[count4]=7;
 313   2      count4++;
 314   2      }
 315   1      }
 316          
 317          void key_manage9()
 318          {
 319   1      tab_key[n]=8;
 320   1      n++;
 321   1      if(xiugaiflag==1)
 322   1      {
 323   2      mima[count4]=8;
 324   2      count4++;
 325   2      }
 326   1      }
 327          void key_manage10()
 328          {
 329   1      tab_key[n]=9;
 330   1      n++;
 331   1      if(xiugaiflag==1)
 332   1      {
 333   2      mima[count4]=9;
 334   2      count4++;
 335   2      }
 336   1      }
 337          //**********************************确认键**************************************************************  
 338          void key_manage11()
 339          {
 340   1              enterflag=1;                                    //确认键按下
 341   1              if(n==8)                                           //只有输入8个密码后按确认才做比较
 342   1                      mimaflag=mimacmp();
 343   1              else
 344   1                      mimaflag=0;
 345   1               if(enterflag==1)
 346   1                      {
 347   2                              enterflag=0;  //标志位清零
 348   2                              n=0;
 349   2                              //用FFFFFFFF清除已经输入的密码
 350   2                              for(count3=0;count3<8;count3++)
 351   2                              {       
 352   3                                      delay(5);
 353   3                                      tab_key[count3]=0x0f;           
 354   3                              }               
 355   2                                              
 356   2                              TR1=1;                                                                  //打开计数器1
 357   2                              count1=0;                                                               //定时器1由50MS累计到1S所用的计数器
 358   2                              if(mimaflag==1)
 359   2                              {       
 360   3                                      a=0;
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 7   

 361   3                              
 362   3                                      write_com(0x01);
 363   3                                      write_com(0x80);
 364   3                                      for(count3=0;count3<16;count3++)
 365   3                                      {
 366   4                                              write_date(table4[count3]);     //密码正确，显示RIGHT，绿灯亮
 367   4                                              delay(5);
 368   4                                      }
 369   3                              }
 370   2                                      
 371   2                          else
 372   2                              {   
 373   3                                      n=0;
 374   3                                      red=0;
 375   3                              bell=0;
 376   3                                      a++;
 377   3                                      if(a==1)
 378   3                                      {
 379   4                                              for(count3=0;count3<8;count3++) //ffffffff清除密码
 380   4                                              {       
 381   5                                                      delay(5);
 382   5                                                      tab_key[count3]=0x0f;           
 383   5                                              }
 384   4                                              write_com(0x01);                                                                                
 385   4                                              write_com(0x80);
 386   4                                              for(count3=0;count3<16;count3++)
 387   4                                              {
 388   5                                                      write_date(table5[count3]);     //密码错误，显示 first error，红灯亮
 389   5                                                      delay(5);
 390   5                                              }
 391   4                                                      TR1=1;
 392   4                                      }
 393   3                                      if(a==2)
 394   3                                      {       
 395   4                                              for(count3=0;count3<8;count3++) //ffffffff清除密码
 396   4                                              {       
 397   5                                                      delay(5);
 398   5                                                      tab_key[count3]=0x0f;           
 399   5                                              }
 400   4                                                      write_com(0x01);
 401   4                                                      write_com(0x80);
 402   4                                                      for(count3=0;count3<16;count3++)
 403   4                                                      {
 404   5                                                              write_date(table6[count3]);     //密码错误，显示SECOND ERROR，红灯亮
 405   5                                                              delay(5);
 406   5                                                      }
 407   4                                                              TR1=1;
 408   4                                      }
 409   3                                              
 410   3                                        if(a==3)
 411   3                                              {       
 412   4                                                      for(count3=0;count3<8;count3++) //ffffffff清除密码
 413   4                                                      {       
 414   5                                                              delay(5);
 415   5                                                              tab_key[count3]=0x0f;           
 416   5                                                      }
 417   4                                                      write_com(0x01);
 418   4                                                      write_com(0x80);
 419   4                                                      for(count3=0;count3<16;count3++)
 420   4                                                      {
 421   5                                                              write_date(table7[count3]);     //密码错误，显示third error see，红灯亮
 422   5                                                              delay(5);
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 8   

 423   5                                                      }
 424   4                                                      write_com(0x80+0x40);
 425   4                                                      for(count3=0;count3<16;count3++)
 426   4                                                      {
 427   5                                                              write_date(table8[count3]);//密码错误，显示 U TOMORROW ,红灯亮
 428   5                                                              delay(5);
 429   5                                                      }
 430   4                                                              TR1=0;
 431   4                                                                      
 432   4                                              }
 433   3                                                              
 434   3                      }
 435   2              }
 436   1      
 437   1      }
 438          void key_manage12()
 439          {
 440   1      tab_key[n]=11;
 441   1      n++;                                              //密码计数清零
 442   1      
 443   1      }
 444          //****************************************************取消键********************************************  
 445          void key_manage13()
 446          {
 447   1      
 448   1      n=0;                                              //密码计数清零
 449   1      write_com(0x80);                                                //指针所指位置     第一行
 450   1      for(count3=0;count3<16;count3++)
 451   1      {
 452   2              write_date(table1[count3]);             //第一行显示INPUT THE PASSPORD:
 453   2              delay(5);
 454   2      }
 455   1      write_com(0x80+0x40);                            //第二行
 456   1      for(count3=0;count3<16;count3++)
 457   1      {
 458   2              write_date(table2[count3]);     //开机显示--------
 459   2              delay(5);
 460   2              tab_key[count3]=0x0f;                   //用FFFFFFFF清除已经输入的密码
 461   2      }
 462   1      
 463   1      }
 464          //*******************************************修改密码键**********************************
 465          void key_manage14()
 466          {
 467   1              uchar aa=0;
 468   1              n=0;
 469   1              xiugaiflag=1;
 470   1              write_com(0x01);
 471   1              write_com(0x80);
 472   1      for(count3=0;count3<16;count3++)
 473   1      {
 474   2              write_date(table9[count3]);     //显示define the password
 475   2              delay(5);
 476   2              tab_key[count3]=0x0f;                   //用FFFFFFFF清楚已经输入的密码
 477   2      }
 478   1              write_com(0x80+0x40);
 479   1      for(count3=0;count3<16;count3++)
 480   1      {
 481   2              write_date(table10[count3]);    //显示--------
 482   2              delay(5);
 483   2      }
 484   1      TR0=1;
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 9   

 485   1      
 486   1      }
 487          //******************************************修改密码键的确认键********************************
 488          void key_manage15()
 489          {
 490   1      n=0;
 491   1      enter1flag=1;
 492   1      if(enter1flag==1)
 493   1      {
 494   2              enter1flag=0;
 495   2              count4=0;
 496   2              for(count3=0;count3<16;count3++)
 497   2              {
 498   3              tab_key[count3]=0x0f;                   //用FFFFFFFF清除已经输入的密码
 499   3              }
 500   2              write_com(0x01);
 501   2              write_com(0x80);
 502   2              for(count3=0;count3<16;count3++)
 503   2              {
 504   3                      write_date(table11[count3]);
 505   3                      delay(100);
 506   3              }
 507   2              TR1=1;
 508   2              count1=0;
 509   2      }
 510   1      }
 511          void key_manage16()
 512          {
 513   1      tab_key[n]=15;
 514   1      n++;
 515   1      }
 516          
 517          //****************************************定时器1的50MS,共延时1秒*****************************
 518          void time_1() interrupt 3
 519          {       
 520   1      
 521   1              TH1=(65536-50000)/256;
 522   1              TL1=(65536-50000)%256;
 523   1              if(count1<20)
 524   1              {
 525   2                      count1++;
 526   2              }
 527   1              else                                                    //计时到1S
 528   1              {
 529   2                      TR1=0;
 530   2                      count1=0;
 531   2                      mimaflag=0;
 532   2      
 533   2                      red=1;
 534   2                      bell=1;
 535   2                      //显示FFFFFFFF
 536   2                      write_com(0x01);
 537   2                      write_com(0x80);
 538   2                      for(count3=0;count3<16;count3++)
 539   2                              {
 540   3                                      write_date(table1[count3]);     //显示INPUT THE PASSCODE
 541   3                                      delay(5);
 542   3                              }
 543   2                      write_com(0x80+0x40);
 544   2                      for(count3=0;count3<16;count3++)
 545   2                              {
 546   3                                      write_date(table2[count3]);     //开机显示FFFFFFFF
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 10  

 547   3                                      delay(5);
 548   3                              }
 549   2              }
 550   1      
 551   1      }
 552          //***********************************************定时0**********************************************
 553          void time_0() interrupt 1
 554          {       
 555   1      
 556   1              TH0=(65536-50000)/256;
 557   1              TL0=(65536-50000)%256;
 558   1      if(count4<8)
 559   1      {
 560   2              key_scan();
 561   2      }
 562   1      else
 563   1      {
 564   2              TR0=0;
 565   2              count4=0;
 566   2      }
 567   1      }
 568          
 569          //初始化函数
 570          void init()
 571          {       
 572   1              uchar i;
 573   1              lcden=0;
 574   1              write_com(0x38);                                        //打开显示模式设置
 575   1              write_com(0x0c);                                        //打开显示，光标等等设置为零
 576   1              write_com(0x06);                                        //当读或写一个字符后地址指针加一，且光标加一，当写一个字符后整频显示左移，
 577   1              write_com(0x01);                                        //清零指令
 578   1              write_com(0x80);                                        //指针所指位置
 579   1      
 580   1              //定时器初始化
 581   1              TMOD=0x11;                                                      //T0,T1工作方式1
 582   1              TH0=(65536-2000)/256;
 583   1              TL0=(65536-2000)%256;                           //T0初始化2MS
 584   1      
 585   1              TH1=(65536-50000)/256;
 586   1              TL1=(65536-50000)%256;                          //T1初始化50MS
 587   1      
 588   1              TR1=0;
 589   1              ET1=1;
 590   1              EA=1;
 591   1              TR0=0;
 592   1              ET0=1;
 593   1      
 594   1              count0=0;                                                       //初始没有密码输入，故为零
 595   1              enterflag=0;                                            //没有确认键按下
 596   1              mimaflag=0;                                                     //密码正确与否键先置零
 597   1                                              
 598   1              red=1;                                                          //红灯不亮
 599   1      //************密码存入EPROM中**********************************
 600   1              sda=1;
 601   1              delay(5);
 602   1              scl=1;// SDA=1,SCL=1,使主从设备处于空闲状态
 603   1              delay(5);
 604   1              for(i=0;i<8;i++)
 605   1              {
 606   2                      write_add(i,8);
 607   2                      delay3(100);
 608   2              }
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 11  

 609   1              for(i=0;i<8;i++)
 610   1              {
 611   2                      mima[i]=read_add(i);
 612   2                      delay(5);
 613   2              }
 614   1      
 615   1      }
 616          void main()
 617          {       rw=0;           
 618   1              init();
 619   1              write_com(0x80);                                                //给com一个数值，com连着单片机
 620   1              for(count3=0;count3<16;count3++)
 621   1              {
 622   2                      write_date(table1[count3]);             //第一行显示INPUT THE PASSPORD:
 623   2                      delay(5);
 624   2              }
 625   1              write_com(0x80+0x40);
 626   1              for(count3=0;count3<16;count3++)
 627   1              {
 628   2                      write_date(table2[count3]);             //开机显示FFFFFFFF
 629   2                      delay(5);
 630   2              }
 631   1              while(1)
 632   1              {
 633   2                      key_scan();                                             //调用键盘扫描函数
 634   2                      lcd_display(); 
 635   2              }
 636   1                       
 637   1      }
 638          //******************************************************************键盘扫描函数开始**********************
             -*********************************************
 639          void key_scan()
 640          {
 641   1      //**********扫描第一行*********
 642   1      P1=0xfe; 
 643   1      temp=P1;
 644   1      temp=temp&0xf0;
 645   1      if(temp!=0xf0)
 646   1      {
 647   2      delay(100);
 648   2      if(temp!=0xf0)
 649   2      {
 650   3      temp=P1;
 651   3      switch(temp)
 652   3      {
 653   4      case 0xee:
 654   4      key_manage1();
 655   4      break;
 656   4      
 657   4      case 0xde:
 658   4      key_manage2();
 659   4      break;
 660   4      
 661   4      case 0xbe:
 662   4      key_manage3();
 663   4      break;
 664   4      
 665   4      case 0x7e:
 666   4      key_manage4();
 667   4      break;
 668   4      }
 669   3      while(temp!=0xf0)
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 12  

 670   3      {
 671   4      temp=P1;
 672   4      temp=temp&0xf0;
 673   4      }
 674   3      }
 675   2      }
 676   1      //**************************************************扫描第二行***********************************
 677   1      P1=0xfd; 
 678   1      temp=P1;
 679   1      temp=temp&0xf0;
 680   1      if(temp!=0xf0)
 681   1      {
 682   2      delay(100);
 683   2      if(temp!=0xf0)
 684   2      {
 685   3      temp=P1;
 686   3      switch(temp)
 687   3      {
 688   4      case 0xed:
 689   4      key_manage5();
 690   4      break;
 691   4      
 692   4      case 0xdd:
 693   4      key_manage6();
 694   4      break;
 695   4      
 696   4      case 0xbd:
 697   4      key_manage7();
 698   4      break;
 699   4      
 700   4      case 0x7d:
 701   4      key_manage8();
 702   4      break;
 703   4      }
 704   3      while(temp!=0xf0)
 705   3      {
 706   4      temp=P1;
 707   4      temp=temp&0xf0;
 708   4      }
 709   3      }
 710   2      }
 711   1      //*********************************************扫描第三行***********************************
 712   1      P1=0xfb; 
 713   1      temp=P1;
 714   1      temp=temp&0xf0;
 715   1      if(temp!=0xf0)
 716   1      {
 717   2      delay(100);
 718   2      if(temp!=0xf0)
 719   2      {
 720   3      temp=P1;
 721   3      switch(temp)
 722   3      {
 723   4      case 0xeb:
 724   4      key_manage9();
 725   4      break;
 726   4      
 727   4      case 0xdb:
 728   4      key_manage10();
 729   4      break;
 730   4      
 731   4      case 0xbb:
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 13  

 732   4      key_manage11();
 733   4      break;
 734   4      
 735   4      case 0x7b:
 736   4      key_manage12();
 737   4      break;
 738   4      }
 739   3      while(temp!=0xf0)
 740   3      {
 741   4      temp=P1;
 742   4      temp=temp&0xf0;
 743   4      }
 744   3      }
 745   2      }
 746   1      
 747   1      //***************************************************扫描第四行****************************************
 748   1      P1=0xf7;
 749   1      temp=P1;
 750   1      temp=temp&0xf0;
 751   1      if(temp!=0xf0)
 752   1      {
 753   2      delay(100);
 754   2      if(temp!=0xf0)
 755   2      {
 756   3      temp=P1;
 757   3      switch(temp)
 758   3      {
 759   4      case 0xe7:
 760   4      key_manage13();
 761   4      break;
 762   4      
 763   4      case 0xd7:
 764   4      key_manage14();
 765   4      break;
 766   4      
 767   4      case 0xb7:
 768   4      key_manage15();
 769   4      break;
 770   4      
 771   4      case 0x77:
 772   4      key_manage16();
 773   4      break;
 774   4      }
 775   3      while(temp!=0xf0)
 776   3      {
 777   4      temp=P1;
 778   4      temp=temp&0xf0;
 779   4      }
 780   3      }
 781   2      }
 782   1      } 
 783          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1749    ----
   CONSTANT SIZE    =    188    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     67       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       1
C51 COMPILER V8.02   PASSWORD                                                              03/08/2016 09:45:55 PAGE 14  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
